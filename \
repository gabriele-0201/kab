
#[repr(C)]
struct SegmentDescriptor {
    low_limit: u16,
    low_base: u16,
    mid_base: u8,
    access_type: u8,
    high_limit_and_flags: HighLimitAndFlags,
    high_base: u8,
}

impl SegmentDescriptor {

    fn new(base: u32, limit: u32, access_type: u8, flags: u8) -> Self {

        // limit is more complex to evaluate it could work with 16 o 32 bit:
        //  16 bit:
        //      the limit is less than 65536
        //  32 bit:
        //      the 12 least significant bit could be discarted ONLY if they are all 1
        //          in this case the 12 bits up to one is implicity
        //      if they are not all 1 than the solution is:
        //          make all the 12 bits to 1 but remove the 13th bit,
        //          this solution does not give more limit than expected but could reduce it,
        //          this create a wasta space
        
        let flags: u8;

        if limit < 65536 {
            flags = 0x40; // flags for 16 bit mode
        } else {
            flags = 0xC0; // flags for 32 bit mode

            if (limit & 0xFFF) == 0xFFF {
                // all 12 bit are 1
                limit = limit >> 12;
            } else {
                // not all 12 bits are 1
                limit = (limit >> 12) - 1;
            }
        }

        SegmentDescriptor {
            low_limit: (limit & 0xFFFF) as u16,
            low_base: (base & 0xFFFF) as u16,
            mid_base: ((base >> 16) & 0xFF) as u8,
            access_type,
            high_limit_and_flags: HighLimitAndFlags::new(limit, flags),
            high_base: ((base >> 24) & 0xFF) as u8
        }

    }
}

#[repr(transparent)]
pub struct HighLimitAndFlags(u8);

impl HighLimitAndFlags {
    /// Limit is surely under 20 bit
    /// Flags has 4 bit
    pub fn new(limit: u32, flags: u8) -> Self {
        HighLimitAndFlags((((limit >> 16 & 0xF) | (flags << 4) as u32) & 0xFF) as u8)
    }
}

#[repr(C)]
struct GDT {

    // SD = SegmentDescriptor
    null_sd: SegmentDescriptor,
    code_sd: SegmentDescriptor,
    data_sd: SegmentDescriptor,
    stack_sd: SegmentDescriptor,

}

impl GDT {
    pub fn new() -> Self {
        GDT {
            SegmentDescriptor::new(),
            SegmentDescriptor::new(),
            SegmentDescriptor::new(),
            SegmentDescriptor::new(),
        } 
    }

    pub fn get_kernel_code_segment_offset() -> u32 {

    }

    pub fn get_kernel_data_segment_offset() -> u32 {

    }
}
